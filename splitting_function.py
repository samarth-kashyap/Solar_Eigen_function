import numpy as np
import scipy.special as sp 
import h_components as hcomps
import get_kernels_herm as gkerns
import functions as fn
import scipy.integrate
import matplotlib.pyplot as plt 
import random
plt.ion()

#Modes whose splitting function is to be computed
n,l = 10,3
n_,l_ = 9,4

r = np.loadtxt('r.dat')
r_start, r_end = 0.,1.
start_ind, end_ind = [fn.nearest_index(r, pt) for pt in (r_start, r_end)]
r = r[start_ind:end_ind]

#Lorentz stress components' order
s = np.array([1,2,3])
smax = np.amax(s)
s_H = 2*smax + 1         #triangle law 0 <= s_H <= 2s;    s_H for H and s for B

om = np.vectorize(fn.omega,otypes=[float])
wig_val = np.vectorize(fn.wig,otypes=[float])

#B magnitude profile as a function of radius which is simply squared to get H magnitude for different components
def B0_st_profile(r):
    beta = 1e-4/r**3  #10G on surface
    #1e5 Gauss at tachocline
    beta += np.exp(-0.5*((r-0.7)/0.01)**2)
    #1e7 Gauss at core
    beta += 100*np.exp(-0.5*(r/0.1)**2)
    return beta

def ret_Bcomps(s,r):
    B0_st = B0_st_profile(r)
    #Implementing the solenoidal condition
    gradr_B0st = (np.gradient(r**2*B0_st,r)/r)[np.newaxis,:]/om(s,0)[:,np.newaxis]      #shape s x r
    rand_factors = np.zeros((smax,2*smax+1))
    one_factors = np.zeros((smax,2*smax+1))
    for s0 in s:
        rand_factors[s0-1,smax-s0:smax+s0+1] = np.array([random.random() for i in range(2*s0+1)]) #shape s x t
        one_factors[s0-1,smax-s0:smax+s0+1] = np.array([1.0 for i in range(2*s0+1)]) #shape s x t

    B0_st = B0_st[np.newaxis,:]*rand_factors[:,:,np.newaxis]
    gradr_B0st = gradr_B0st[:,np.newaxis,:]*rand_factors[:,:,np.newaxis]
    Bp_st = rand_factors[:,:,np.newaxis]*gradr_B0st    #shape s x t x r
    Bm_st = gradr_B0st - Bp_st

    B_st_total = np.zeros((3,smax,2*smax+1,len(r)))
    B_st_total[0] = Bm_st
    B_st_total[1] = B0_st
    B_st_total[2] = Bp_st
    return B_st_total

def ret_Hcomps(mu,nu,s0,t0):
    #computing the brute force way
#     H_st = np.zeros(len(r))
#     for s1 in s:
#         for s2 in s:
#             for t1 in range(-s1,s1+1):
#                 for t2 in range(-s2,s2+1):
#                 #     print(s1,s2,t1)
#                     H_st_temp = B_st[mu,s1-1,t1+smax,:]*B_st[nu,s2-1,t2+smax,:]
#                     H_st_temp = H_st_temp * (-1)**(np.abs(mu+nu+t0)) * np.sqrt((2*s0+1.)*(2*s1+1.)*(2*s2+1.)/(4.* np.pi))
#                     H_st_temp = H_st_temp * wig_val(s0,s1,s2,-t0,t1,t2) * wig_val(s0,s1,s2,-(mu+nu),mu,nu)
#                     H_st += H_st_temp

    #computing using numpy array handling

    H_st_mat = B_st[mu,:,:,np.newaxis,np.newaxis,:]*B_st[nu,np.newaxis,np.newaxis,:,:,:]
    t = np.arange(-smax,smax+1)
    ss1,tt1,ss2,tt2 = np.meshgrid(s,t,s,t,indexing='ij')

    prefactor = (-1)**(np.abs(mu+nu+t0)) * np.sqrt((2*s0+1.)*(2*ss1+1.)*(2*ss2+1.)/(4.* np.pi))
    prefactor *= wig_val(s0,ss1,ss2,-t0,tt1,tt2) * wig_val(s0,ss1,ss2,-(mu+nu),mu,nu)

    H_st_mat = H_st_mat * prefactor[:,:,:,:,np.newaxis]
    H_st_mat = np.sum(H_st_mat,axis=(0,1,2,3))

    return H_st_mat


#getting the kernel components


m = np.arange(-l,l+1,1)    #-l<=m<=l
m_ = np.arange(-l_,l_+1,1)  #-l_<=m<=l_ 

s_H_arr = np.arange(s_H)

kern = gkerns.Hkernels(n_,l_,m_,n,l,m,s_H_arr,r,False)
Bmm,B0m,B00,Bpm,Bp0,Bpp = kern.ret_splittingfunction_terms(smoothen=True)

npts = 300   #check the npts in get_kernels
r_new = np.linspace(np.amin(r),np.amax(r),npts)
r = r_new

B_st = ret_Bcomps(s,r)     #computes all components of all st of 

#finding the H-components
Hmm_str = np.zeros((s_H,2*s_H+1,len(r)))
H0m_str = np.zeros((s_H,2*s_H+1,len(r)))
H00_str = np.zeros((s_H,2*s_H+1,len(r)))
Hpm_str = np.zeros((s_H,2*s_H+1,len(r)))
H0p_str = np.zeros((s_H,2*s_H+1,len(r)))
Hpp_str = np.zeros((s_H,2*s_H+1,len(r)))

print('Here')

for s0 in range(s_H):    
#     for t0 in range(-s0,0):
#             Hmm_str[s0,t0+s_H,:]  = ret_Hcomps(-1,-1,s0,t0)
#             H0m_str[s0,t0+s_H,:]  = ret_Hcomps(0,-1,s0,t0)
#             H00_str[s0,t0+s_H,:]  = ret_Hcomps(0,0,s0,t0)
#             Hpm_str[s0,t0+s_H,:]  = ret_Hcomps(1,-1,s0,t0)

#             #Imposing the realness of H along with its symmetry in mu,nu
#             Hpp_str[s0,-t0+s_H,:] = (-1)**(np.abs(t0)) * np.conj(Hmm_str[s0,t0+s_H,:])
#             H0p_str[s0,-t0+s_H,:] = (-1)**(np.abs(t0)) * np.conj(H0m_str[s0,t0+s_H,:])

#             H00_str[s0,-t0+s_H,:] = (-1)**(np.abs(t0)) * np.conj(H00_str[s0,t0+s_H,:])
#             Hpm_str[s0,-t0+s_H,:] = (-1)**(np.abs(t0)) * np.conj(Hpm_str[s0,t0+s_H,:])

#     for t0 in range(0,s0+1):
#             Hmm_str[s0,t0+s_H,:]  = ret_Hcomps(-1,-1,s0,t0)
#             H0m_str[s0,t0+s_H,:]  = ret_Hcomps(0,-1,s0,t0)

#             #Imposing the realness of H along with its symmetry in mu,nu
#             Hpp_str[s0,-t0+s_H,:] = (-1)**(np.abs(t0)) * np.conj(Hmm_str[s0,t0+s_H,:])
#             H0p_str[s0,-t0+s_H,:] = (-1)**(np.abs(t0)) * np.conj(H0m_str[s0,t0+s_H,:])

    for t0 in range(-s0,s0+1):
            Hmm_str[s0,t0+s_H,:] = ret_Hcomps(-1,-1,s0,t0)
            H0m_str[s0,t0+s_H,:] = ret_Hcomps(0,-1,s0,t0)
            H00_str[s0,t0+s_H,:] = ret_Hcomps(0,0,s0,t0)
            Hpm_str[s0,t0+s_H,:] = ret_Hcomps(1,-1,s0,t0)
            Hpp_str[s0,t0+s_H,:] = ret_Hcomps(1,1,s0,t0)
            H0p_str[s0,t0+s_H,:] = ret_Hcomps(0,1,s0,t0)

            
    print(s0,t0)

#plotting on Mollweide projection
theta = np.linspace(-np.pi/2,np.pi/2,360)
phi = np.linspace(-np.pi,np.pi,720)

thth,phph = np.meshgrid(theta,phi,indexing='ij')

#find integrand by summing all component
Lambda_str = Hpp_str*Bpp[:,np.newaxis,:] + H00_str*B00[:,np.newaxis,:] + Hmm_str*Bmm[:,np.newaxis,:] \
        + 2*Hpm_str*Bpm[:,np.newaxis,:] + 2*H0m_str*B0m[:,np.newaxis,:] + 2*H0p_str*Bp0[:,np.newaxis,:]

#radial integral
Lambda_st = scipy.integrate.trapz(Lambda_str*(r**2),x=r,axis=2)

t = np.arange(-s_H,s_H+1)
ss, tt = np.meshgrid(s_H_arr,t,indexing='ij')

z = np.zeros(np.shape(thth),dtype='complex128')

fig = plt.figure()
ax = fig.add_subplot(111, projection='mollweide')

for s0 in s_H_arr:
    for t0 in range(-s0,s0+1):
        z += Lambda_st[s0,t0+s_H]*sp.sph_harm(t0,s0,phph,thth)
        
im = ax.pcolormesh(phph,thth,np.real(z), cmap=plt.cm.jet)
#  plt.colorbar()  







